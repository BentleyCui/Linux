
### IPC ( InterProcess Communication )

Linux 环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，要交换数据必须通过内核，在内核中开辟一块缓冲区，进程 1 把数据从用户空间拷到内核缓冲区，进程 2 再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC， InterProcess Communication）。  

**本质：内核空间中的一块缓冲区**

![image](https://user-images.githubusercontent.com/59153788/167784041-dee74ba8-0eed-4bc1-9edb-b9c03298a29b.png)

现今常用的进程间通信方式有：  

**（1）管道**（简单）

**（2）信号**（开销最小）

**（3）共享映射区**（没有血缘关系的）

**（4）本地套接字**（最稳定）



### 管道

管道是一种最基本的 IPC 机制， **作用于有血缘关系的进程**之间，完成数据传递。调用 pipe 系统函数即可创建一个管道。  

有如下特质：

1. 其本质是一个**伪文件**(实为内核缓冲区)
2. 由两个文件描述符引用，一个表示**读端**，一个表示**写端**。  
3. 规定数据从管道的写端流入管道，从读端流出。  

管道的原理: 管道实为内核使用**环形队列**机制，借助内核缓冲区(4k)实现。  

**局限性：**

1. 数据不能自己写，自己读。  
2. 管道中数据**不可反复读取**。一旦读走，管道中不再存在。  
3. 采用**半双工通信**方式，数据只能在单方向上流动。  



### pipe函数

创建，并打开管道

```c
int pipe(int pipefd[2]);
参数：
    fd[0]:读端
    fd[1]:写端
返回值：
    成功：0
    失败：-1，设置errno
```

管道创建成功以后， 创建该管道的进程（父进程） 同时掌握着管道的读端和写端。  

<img src="https://user-images.githubusercontent.com/59153788/167789156-f243f32a-2f41-40f3-8e45-7c9b72293c26.png" alt="image" style="zoom: 80%;" />

1. 父进程调用 pipe 函数创建管道，得到两个文件描述符 fd[0]、 fd[1]指向管道的读端和写端。
2. 父进程调用 fork 创建子进程，那么子进程也有两个文件描述符指向同一管道。  
3. 父进程关闭管道读端，子进程关闭管道写端。父进程可以向管道中写入数据，子进程将管道中的数据读出。由于管道是利用环形队列实现的，数据从写端流入管道，从读端流出，这样就实现了进程间通信。  

  

### 管道的读写行为

1. **读管道：**
   1. 管道中有数据：read 返回实际读到的字节数  
   2. 管道中无数据：
      1. 管道写端被全部关闭：read 返回 0 (好像读到文件结尾)  
      2. 写端没有全部被关闭：read 阻塞等待(不久的将来可能有数据递达，此时会让出 cpu)  
2. **写管道：**
   1. 管道读端全部被关闭， 进程异常终止(也可使用捕捉SIGPIPE 信号，使进程不终止)  
   2. 管道读端没有全部关闭：
      1. 管道已满：write阻塞
      2. 管道未满：write 将数据写入，并返回实际写入的字节数  

**练习：**

使用管道实现父子进程间通信，完成： ls | wc –l。 假定父进程实现 ls， 子进程实现 wc。

ls 命令正常会将结果集写出到 stdout，但现在会写入管道的写端； wc –l 正常应该从 stdin 读取数据， 但此时会从管道的读端读。  

```c
pipe_lswc.cpp
功能：实现 ls | wc -l 命令
```



###  FIFO 命名管道

管道(pipe)只能用于“有血缘关系”的进程间。但通过 FIFO，不相关的进程也能交换数据。

FIFO 是 Linux 基础文件类型中的一种。但， FIFO 文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行 read/write， 实际上是在读写内核通道，这样就实现了进程间通信。    

**创建命令**：

（1）命令：**mkfifo**

（2）库函数： int mkfifo(const char *pathname, mode_t mode);   成功： 0； 失败： -1  

一旦使用 mkfifo 创建了一个 FIFO， 就可以使用 open 打开它， 常见的文件 I/O 函数都可用于 fifo。 如： close、 read、write、 unlink 等。  













