## 什么是mmap

memory map, 即地址的映射, 是一**内存映射**文件的方法

将一个文件或者其它对象映射到进程的地址空间，实现**文件磁盘地址**和**进程虚拟地址空间**中一段虚拟地址的一一对映关系。mmap()系统调用使得进程之间通过映射同一个普通文件实现**共享内存**。文件被映射到进程地址空间后，进程可以像访问内存一样对文件进行访问，而系统会自动回写脏页面到对应的文件磁盘上，不必再调用read()，write（）等操作。

**内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享**

![image](https://user-images.githubusercontent.com/59153788/176486499-ed394dd1-9a5e-4396-82b4-8a5b4e5f7b63.png)

为内存映射服务的地址空间处在堆栈之间的空余部分



linux内核使用**vm_area_struct结构**来表示一个独立的虚拟内存区域，由于每个不同质的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个vm_area_struct结构来分别表示不同类型的虚拟内存区域。各个vm_area_struct结构使用链表或者树形结构链接，方便进程快速访问，如下图所示：

![image](https://user-images.githubusercontent.com/59153788/176486930-1ca0867e-d9da-491a-9115-78a2e64cc113.png)



vm_area_struct结构中包含区域起始和终止地址以及其他相关信息，同时也包含一个vm_ops指针，其内部可引出所有针对这个区域可以使用的系统调用函数。这样，进程对某一虚拟内存区域的任何操作需要用要的信息，都可以从vm_area_struct中获得。**mmap函数就是要创建一个新的vm_area_struct结构，并将其与文件的物理磁盘地址相连。**

## 为什么使用mmap()

Linux通过内存映像机制来提供用户程序对内存直接访问的能力。**内存映像**的意思是把内核中特定部分的内存空间映射到用户级程序的内存空间去。也就是说，**用户空间和内核空间共享一块相同的内存**。这样做的直观效果显而易见：内核在这块地址内存储变更的任何数据，用户可以立即发现和使用，根本无须数据拷贝。举个例子理解一下，使用mmap方式获取磁盘上的文件信息，只需要将磁盘上的数据拷贝至那块共享内存中去，用户进程可以直接获取到信息，而相对于传统的write/read　IO系统调用, 必须先把数据从磁盘拷贝至到内核缓冲区中(页缓冲)，然后再把数据拷贝至用户进程中。两者相比，mmap会少一次拷贝数据，这样带来的性能提升是巨大的。

使用内存访问来取代read()和write()系统调用能够简化一些应用程序的逻辑，在一些情况下，它能够比使用传统的I/O系统调用执行文件I/O这种做法提供更好的性能：

1. 正常的read()或write()需要两次传输：一次是在文件和内核高速缓冲区之间，另一次是在高速缓冲区和用户空间缓冲区之间。使用mmap()就不需要第二次传输了。对于输入来讲，一旦内核将相应的文件块映射进内存之后，用户进程就能够使用这些数据了；对于输出来讲，用户进程仅仅需要修改内核中的内容，然后可以依靠内核内存管理器来自动更新底层的文件。
2. 除了节省内核空间和用户空间之间的一次传输之外，mmap()还能够通过减少所需使用的内存来提升性能。当使用read()或write()时，数据将被保存在两个缓冲区中：一个位于用户空间，另个一位于内核空间。当使用mmap()时，内核空间和用户空间会共享同一个缓冲区。此外，如果多个进程正在同一个文件上执行I/O，那么它们通过使用mmap()就能够共享同一个内核缓冲区，从而又能够节省内存的消耗。

## 如何使用mmap

```c++
#include <sys/mman.h>
void *mmap(void *adrr, size_t length, int prot, int flags, int fd, off_t offset);
参数：
	addr: 建立映射区的首地址，由 Linux 内核指定。使用时，直接传递 NULL
	length： 欲创建映射区的大小
	prot： 映射区权限 PROT_READ、PROT_WRITE、PROT_READ|PROT_WRITE
	flags： 标志位参数(常用于设定更新物理区域、设置共享、创建匿名映射区)
 			MAP_SHARED: 会将映射区所做的操作反映到物理设备（磁盘）上。
 			MAP_PRIVATE: 映射区所做的修改不会反映到物理设备。
	fd： 用来建立映射区的文件描述符
	offset： 映射文件的偏移(4k 的整数倍)
	
int munmap(void *addr, size_t length);
```

## 两种映射方式

### 1.基于文件的映射

适用于任何进程之间, 此时，需要打开或创建一个文件，然后再调用mmap()

```c++
fd = open();
if(fd < 0){
	printf("error\n");
}

ptr = mmap(NULL, len, PORT_READ|PORT_WRITE|PORT_EXEC, MAP_SHARED, fd, 0);
```

这样用户进程就可以像读取内存一样读取文件了,效率非常高

### 2.匿名映射

匿名映射是一种没用对应文件的一种映射，是使用特殊文件提供的匿名内存映射：
一个匿名映射没有对应的文件，这种映射的分页会被初始化为0。可以把它看成是一个内容总是被初始化为0的虚拟文件映射，比如在具有血缘关系的进程之间，如父子进程之间,　当一个进程调用mmap().之后又调用了fork(), 之后子进程会继承(拷贝)父进程映射后的空间，同时也继承了mmap()的返回地址，通过修改数据共享内存里的数据,　父子进程够可以感知到数据的变化，这样一来，父子进程就可以通过这块共享内存来实现进程间通信。

```c++
ptr = mmap();

pid = fork();
switch(pid){
	case pid < 0:
		printf("error\n");
	case pid == 0:
		//使用互斥的方式访问共享内存
		lock(ptr)
		//修改数据;
		unlock(ptr);
	case pid > 0:
		lock(ptr);
		//修改数据;
		unlock(ptr);
}
```

## mmap()具体原理

### （一）进程启动映射过程，并在虚拟地址空间中为映射创建虚拟映射区域

1. 进程在用户空间调用库函数mmap，原型：void *mmap(void *start, size_t length, int prot, int flags, int fd, off_t offset);

2. 在当前进程的虚拟地址空间中，寻找一段空闲的满足要求的连续的虚拟地址

3. 为此虚拟区分配一个vm_area_struct结构，接着对这个结构的各个域进行了初始化

4. 将新建的虚拟区结构（vm_area_struct）插入进程的虚拟地址区域链表或树中

### (二) 调用内核空间的系统调用函数mmap()，实现文件物理地址和进程虚拟地址的一一映射关系

5. 为映射分配了新的虚拟地址区域后，通过待映射的文件指针，在文件描述符表中找到对应的文件描述符，通过文件描述符，链接到内核“已打开文件集”中该文件的文件结构体（struct file），每个文件结构体维护着和这个已打开文件相关各项信息。
6. 通过该文件的文件结构体，链接到file_operations模块，调用内核函数mmap，其原型为：int mmap(struct file *filp, struct vm_area_struct *vma)，不同于用户空间库函数。
7. 内核mmap函数通过虚拟文件系统inode模块定位到文件磁盘物理地址。
8. 通过remap_pfn_range函数建立页表，即实现了文件地址和虚拟地址区域的映射关系。此时，这片虚拟地址并没有任何数据关联到主存中。

### (三) 进程发起对这片映射空间的访问，引发缺页异常，实现文件内容到物理内存（主存）的拷贝

注：前两个阶段仅在于创建虚拟区间并完成地址映射，但是并没有将任何文件数据的拷贝至主存。真正的文件读取是当进程发起读或写操作时。

9. 进程的读或写操作访问虚拟地址空间这一段映射地址，通过查询页表，发现这一段地址并不在物理页面上。因为目前只建立了地址映射，真正的硬盘数据还没有拷贝到内存中，因此引发缺页异常。
10. 缺页异常进行一系列判断，确定无非法操作后，内核发起请求调页过程。
11. 调页过程先在交换缓存空间（swap cache）中寻找需要访问的内存页，如果没有则调用nopage函数把所缺的页从磁盘装入到主存中。
12. 之后进程即可对这片主存进行读或者写的操作，如果写操作改变了其内容，一定时间后系统会自动回写脏页面到对应磁盘地址，也即完成了写入到文件的过程。

## mmap()优缺点

### 优点：

1. 对文件的读取操作跨过了页缓存，减少了数据的拷贝次数，用内存读写取代I/O读写，提高了文件读取效率。
2. 实现了用户空间和内核空间的高效交互方式。两空间的各自修改操作可以直接反映在映射的区域内，从而被对方空间及时捕捉。
3. 提供进程间共享内存及相互通信的方式。不管是父子进程还是无亲缘关系的进程，都可以将自身用户空间映射到同一个文件或匿名映射到同一片区域。从而通过各自对映射区域的改动，达到进程间通信和进程间共享的目的。同时，如果进程A和进程B都映射了区域C，当A第一次读取C时通过缺页从磁盘复制文件页到内存中；但当B再读C的相同页面时，虽然也会产生缺页异常，但是不再需要从磁盘中复制文件过来，而可直接使用已经保存在内存中的文件数据。
4. 可用于实现高效的大规模数据传输。内存空间不足，是制约大数据操作的一个方面，解决方案往往是借助硬盘空间协助操作，补充内存的不足。但是进一步会造成大量的文件I/O操作，极大影响效率。这个问题可以通过mmap映射很好的解决。换句话说，但凡是需要用磁盘空间代替内存的时候，mmap都可以发挥其功效。

### 缺点：

1. 对变长文件不适合.
2. 如果更新文件的操作很多，mmap避免两态拷贝的优势就被摊还，最终还是落在了大量的脏页回写及由此引发的随机IO上.　所以在随机写很多的情况下，mmap方式在效率上不一定会比带缓冲区的一般写快.

